<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fondo CÃ©sped Interactivo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
        }

        #controls label {
            display: block;
            margin: 8px 0;
        }

        #controls select, #controls input {
            margin-left: 10px;
            padding: 3px;
            border-radius: 3px;
        }

        .info {
            margin-top: 10px;
            font-size: 11px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <label>
            Hora:
            <input type="range" id="hourSlider" min="0" max="23" value="12">
            <span id="hourDisplay">12:00</span>
        </label>
        <label>
            Clima:
            <select id="weatherSelect">
                <option value="clear">Despejado</option>
                <option value="rain">Lluvia</option>
                <option value="windy">Viento fuerte</option>
            </select>
        </label>
        <label>
            <input type="checkbox" id="autoMode" checked>
            Modo automÃ¡tico (hora real)
        </label>
        <div class="info">
            ðŸŒ… Amanece: 6:00<br>
            ðŸŒ‡ Atardece: 18:00<br>
            ðŸŒ™ Noche: 20:00-5:00
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // ConfiguraciÃ³n
        let currentHour = new Date().getHours();
        let currentWeather = 'clear';
        let autoMode = true;
        
        // Arrays para elementos animados
        let grassBlades = [];
        let fireflies = [];
        let dandelionSeeds = [];
        let raindrops = [];
        let clouds = [];
        let insects = [];
        let particles = [];
        let dewDrops = [];
        let lightningFlashes = [];
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGrass();
            initClouds();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Inicializar cÃ©sped
        function initGrass() {
            grassBlades = [];
            const bladeCount = Math.floor(canvas.width / 2.5);
            for (let i = 0; i < bladeCount; i++) {
                const isBent = Math.random() < 0.15; // 15% de briznas dobladas
                grassBlades.push({
                    x: (i * canvas.width) / bladeCount + (Math.random() - 0.5) * 5,
                    height: 150 + Math.random() * 200,
                    width: 2 + Math.random() * 4,
                    sway: Math.random() * Math.PI * 2,
                    swaySpeed: 0.015 + Math.random() * 0.025,
                    swayAmount: 10 + Math.random() * 25,
                    bent: isBent,
                    bentAngle: isBent ? 0.3 + Math.random() * 0.5 : 0,
                    colorVariation: Math.random() * 30 - 15,
                    thickness: Math.random()
                });
            }
        }
        
        // Inicializar nubes
        function initClouds() {
            clouds = [];
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: 50 + Math.random() * 150,
                    width: 80 + Math.random() * 120,
                    height: 40 + Math.random() * 40,
                    speed: 0.2 + Math.random() * 0.3,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }
        }
        
        // Obtener colores segÃºn hora
        function getSkyColors(hour) {
            // Lluvia - cielo oscuro y tormentoso
            if (currentWeather === 'rain') {
                return {
                    top: [60, 65, 75],
                    bottom: [90, 95, 110],
                    ambient: 0.5
                };
            }
            
            // Amanecer (5-7)
            if (hour >= 5 && hour < 7) {
                const t = (hour - 5) / 2;
                return {
                    top: interpolateColor([25, 25, 60], [135, 206, 235], t),
                    bottom: interpolateColor([255, 140, 100], [255, 200, 150], t),
                    ambient: 0.6 + t * 0.4
                };
            }
            // DÃ­a (7-17)
            else if (hour >= 7 && hour < 17) {
                return {
                    top: [135, 206, 235],
                    bottom: [200, 230, 255],
                    ambient: 1
                };
            }
            // Atardecer (17-20)
            else if (hour >= 17 && hour < 20) {
                const t = (hour - 17) / 3;
                return {
                    top: interpolateColor([135, 206, 235], [50, 30, 80], t),
                    bottom: interpolateColor([255, 150, 100], [100, 50, 100], t),
                    ambient: 1 - t * 0.3
                };
            }
            // Noche (20-24 y 0-5)
            else {
                return {
                    top: [15, 15, 40],
                    bottom: [50, 30, 80],
                    ambient: 0.3
                };
            }
        }
        
        function interpolateColor(color1, color2, t) {
            return [
                Math.round(color1[0] + (color2[0] - color1[0]) * t),
                Math.round(color1[1] + (color2[1] - color1[1]) * t),
                Math.round(color1[2] + (color2[2] - color1[2]) * t)
            ];
        }
        
        // Dibujar cielo con gradiente
        function drawSky() {
            const colors = getSkyColors(currentHour);
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `rgb(${colors.top.join(',')})`);
            gradient.addColorStop(0.6, `rgb(${colors.bottom.join(',')})`);
            
            // TransiciÃ³n suave al color del suelo
            const groundColor = colors.ambient > 0.7 
                ? [60, 100, 60] 
                : [30, 50, 40];
            gradient.addColorStop(1, `rgb(${groundColor.join(',')})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Dibujar rayos de sol (god rays)
        function drawSunRays() {
            if (currentHour < 6 || currentHour >= 18 || currentWeather === 'rain') return;
            
            const dayProgress = (currentHour - 6) / 14;
            const sunX = canvas.width * 0.1 + (canvas.width * 0.8) * dayProgress;
            const sunY = canvas.height * 0.15 + Math.sin(dayProgress * Math.PI) * -canvas.height * 0.15;
            
            // Rayos mÃ¡s visibles al amanecer y atardecer
            let rayOpacity = 0.08;
            if (currentHour >= 6 && currentHour < 8) {
                rayOpacity = 0.15;
            } else if (currentHour >= 17 && currentHour < 19) {
                rayOpacity = 0.12;
            }
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.sin(Date.now() * 0.0001) * 0.1;
                const rayLength = canvas.height * 0.8;
                
                const gradient = ctx.createLinearGradient(
                    sunX, sunY,
                    sunX + Math.cos(angle) * rayLength,
                    sunY + Math.sin(angle) * rayLength
                );
                
                gradient.addColorStop(0, `rgba(255, 250, 200, ${rayOpacity})`);
                gradient.addColorStop(0.3, `rgba(255, 245, 180, ${rayOpacity * 0.5})`);
                gradient.addColorStop(1, 'rgba(255, 250, 200, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(sunX, sunY);
                ctx.arc(sunX, sunY, rayLength, angle - 0.15, angle + 0.15);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Dibujar estrellas
        function drawStars() {
            if (currentHour >= 20 || currentHour < 6) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137.5) % canvas.width;
                    const y = (i * 97.3) % (canvas.height * 0.5);
                    const size = Math.sin(i) > 0.5 ? 2 : 1;
                    const twinkle = Math.sin(Date.now() * 0.001 + i) * 0.3 + 0.7;
                    
                    ctx.globalAlpha = twinkle;
                    ctx.fillRect(x, y, size, size);
                }
                ctx.globalAlpha = 1;
            }
        }
        
        // Dibujar sol o luna
        function drawCelestialBody() {
            const isNight = currentHour >= 20 || currentHour < 6;
            const colors = getSkyColors(currentHour);
            
            if (isNight && currentWeather !== 'rain') {
                // Luna - movimiento de izquierda a derecha
                // Horas de noche: 20-24 (4 horas) y 0-6 (6 horas) = 10 horas totales
                let nightProgress;
                if (currentHour >= 20) {
                    // 20:00 a 23:59 (primeras 4 horas)
                    nightProgress = (currentHour - 20) / 10;
                } else {
                    // 0:00 a 5:59 (Ãºltimas 6 horas)
                    nightProgress = (4 + currentHour) / 10;
                }
                
                const x = canvas.width * 0.1 + (canvas.width * 0.8) * nightProgress;
                const y = canvas.height * 0.15 + Math.sin(nightProgress * Math.PI) * -canvas.height * 0.1;
                
                // Luna con textura realista
                const moonGlow = ctx.createRadialGradient(x, y, 30, x, y, 70);
                moonGlow.addColorStop(0, 'rgba(240, 240, 255, 0.3)');
                moonGlow.addColorStop(1, 'rgba(240, 240, 255, 0)');
                ctx.fillStyle = moonGlow;
                ctx.beginPath();
                ctx.arc(x, y, 70, 0, Math.PI * 2);
                ctx.fill();
                
                // Luna principal con gradiente
                const moonGradient = ctx.createRadialGradient(x - 10, y - 10, 5, x, y, 40);
                moonGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                moonGradient.addColorStop(0.6, 'rgba(240, 240, 255, 0.95)');
                moonGradient.addColorStop(1, 'rgba(200, 200, 230, 0.9)');
                
                ctx.fillStyle = moonGradient;
                ctx.beginPath();
                ctx.arc(x, y, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // CrÃ¡teres con diferentes tamaÃ±os y opacidades
                const craters = [
                    {x: x - 12, y: y - 8, r: 9, opacity: 0.25},
                    {x: x + 8, y: y + 12, r: 7, opacity: 0.2},
                    {x: x - 5, y: y + 18, r: 5, opacity: 0.3},
                    {x: x + 15, y: y - 5, r: 4, opacity: 0.15},
                    {x: x - 18, y: y + 10, r: 6, opacity: 0.22}
                ];
                
                craters.forEach(crater => {
                    const craterGradient = ctx.createRadialGradient(
                        crater.x, crater.y, 0,
                        crater.x, crater.y, crater.r
                    );
                    craterGradient.addColorStop(0, `rgba(180, 180, 210, ${crater.opacity})`);
                    craterGradient.addColorStop(1, `rgba(200, 200, 220, 0)`);
                    
                    ctx.fillStyle = craterGradient;
                    ctx.beginPath();
                    ctx.arc(crater.x, crater.y, crater.r, 0, Math.PI * 2);
                    ctx.fill();
                });
                
            } else if (currentHour >= 6 && currentHour < 20 && currentWeather !== 'rain') {
                // Sol - movimiento de izquierda a derecha
                // Horas de dÃ­a: 6-19 = 14 horas
                const dayProgress = (currentHour - 6) / 14;
                
                const x = canvas.width * 0.1 + (canvas.width * 0.8) * dayProgress;
                const y = canvas.height * 0.15 + Math.sin(dayProgress * Math.PI) * -canvas.height * 0.15;
                
                // Resplandor exterior
                const outerGlow = ctx.createRadialGradient(x, y, 0, x, y, 120);
                outerGlow.addColorStop(0, 'rgba(255, 250, 200, 0.3)');
                outerGlow.addColorStop(0.4, 'rgba(255, 240, 180, 0.15)');
                outerGlow.addColorStop(1, 'rgba(255, 250, 200, 0)');
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(x, y, 120, 0, Math.PI * 2);
                ctx.fill();
                
                // Resplandor medio
                const midGlow = ctx.createRadialGradient(x, y, 0, x, y, 60);
                midGlow.addColorStop(0, 'rgba(255, 245, 200, 0.5)');
                midGlow.addColorStop(1, 'rgba(255, 245, 200, 0)');
                ctx.fillStyle = midGlow;
                ctx.beginPath();
                ctx.arc(x, y, 60, 0, Math.PI * 2);
                ctx.fill();
                
                // Sol principal con gradiente de textura
                const sunGradient = ctx.createRadialGradient(x - 8, y - 8, 0, x, y, 35);
                sunGradient.addColorStop(0, '#FFF4D6');
                sunGradient.addColorStop(0.4, '#FFE082');
                sunGradient.addColorStop(0.7, '#FDB813');
                sunGradient.addColorStop(1, '#F89406');
                
                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(x, y, 35, 0, Math.PI * 2);
                ctx.fill();
                
                // Manchas solares sutiles
                ctx.fillStyle = 'rgba(248, 180, 60, 0.3)';
                ctx.beginPath();
                ctx.arc(x + 10, y - 5, 6, 0, Math.PI * 2);
                ctx.arc(x - 8, y + 8, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Dibujar nubes
        function drawClouds() {
            clouds.forEach(cloud => {
                // Nubes oscuras y densas para lluvia
                if (currentWeather === 'rain') {
                    // Sombra de nube
                    const shadowGradient = ctx.createRadialGradient(
                        cloud.x + cloud.width * 0.5, cloud.y + 20,
                        0,
                        cloud.x + cloud.width * 0.5, cloud.y + 20,
                        cloud.width * 0.8
                    );
                    shadowGradient.addColorStop(0, 'rgba(40, 45, 55, 0.9)');
                    shadowGradient.addColorStop(0.5, 'rgba(60, 65, 75, 0.8)');
                    shadowGradient.addColorStop(1, 'rgba(80, 85, 95, 0.3)');
                    
                    ctx.fillStyle = shadowGradient;
                    ctx.beginPath();
                    ctx.ellipse(cloud.x + cloud.width * 0.5, cloud.y, cloud.width * 0.8, cloud.height * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Capa de nube principal mÃ¡s oscura
                    ctx.fillStyle = 'rgba(50, 55, 65, 0.95)';
                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.height * 0.6, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.25, cloud.y - 5, cloud.height * 0.7, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.5, cloud.y, cloud.height * 0.65, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.7, cloud.y + 3, cloud.height * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bordes iluminados
                    ctx.strokeStyle = 'rgba(120, 125, 135, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y - 5, cloud.height * 0.7, Math.PI * 1.2, Math.PI * 1.8);
                    ctx.stroke();
                } else {
                    // Nubes normales con textura suave
                    const cloudGradient = ctx.createRadialGradient(
                        cloud.x + cloud.width * 0.4, cloud.y - cloud.height * 0.2,
                        0,
                        cloud.x + cloud.width * 0.5, cloud.y,
                        cloud.width * 0.6
                    );
                    cloudGradient.addColorStop(0, `rgba(255, 255, 255, ${cloud.opacity * 1.2})`);
                    cloudGradient.addColorStop(0.6, `rgba(255, 255, 255, ${cloud.opacity})`);
                    cloudGradient.addColorStop(1, `rgba(245, 245, 250, ${cloud.opacity * 0.3})`);
                    
                    ctx.fillStyle = cloudGradient;
                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.height * 0.5, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y, cloud.height * 0.6, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.6, cloud.y, cloud.height * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                cloud.x += cloud.speed * (currentWeather === 'windy' ? 3 : 1) * (currentWeather === 'rain' ? 0.3 : 1);
                if (cloud.x > canvas.width + cloud.width) {
                    cloud.x = -cloud.width;
                    cloud.y = 50 + Math.random() * 150;
                }
            });
        }
        
        // Dibujar partÃ­culas atmosfÃ©ricas
        function drawAtmosphericParticles(time) {
            const isDay = currentHour >= 7 && currentHour < 19;
            const isMorning = currentHour >= 5 && currentHour < 9;
            
            // Crear partÃ­culas
            if (particles.length < 50 && Math.random() < 0.1) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.3 + Math.random() * canvas.height * 0.4,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -0.1 + Math.random() * 0.2,
                    size: 1 + Math.random() * 2,
                    opacity: 0.2 + Math.random() * 0.3,
                    life: 0,
                    maxLife: 100 + Math.random() * 100
                });
            }
            
            particles.forEach((particle, index) => {
                particle.life++;
                const lifeRatio = particle.life / particle.maxLife;
                const currentOpacity = particle.opacity * (1 - lifeRatio);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${currentOpacity})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                
                particle.x += particle.vx + Math.sin(time * 0.001 + particle.y) * 0.2;
                particle.y += particle.vy;
                
                if (particle.life >= particle.maxLife || particle.y < 0 || particle.y > canvas.height) {
                    particles.splice(index, 1);
                }
            });
            
            // Neblina matutina
            if (isMorning && currentWeather !== 'rain') {
                const mistOpacity = Math.max(0, 0.15 - (currentHour - 5) * 0.03);
                ctx.fillStyle = `rgba(200, 220, 240, ${mistOpacity})`;
                ctx.fillRect(0, canvas.height * 0.5, canvas.width, canvas.height * 0.5);
            }
        }
        
        // Dibujar lluvia
        function drawRain() {
            if (currentWeather !== 'rain') {
                lightningFlashes = [];
                return;
            }
            
            // Crear nuevas gotas
            if (raindrops.length < 300 && Math.random() < 0.8) {
                raindrops.push({
                    x: Math.random() * canvas.width,
                    y: -10,
                    speed: 18 + Math.random() * 12,
                    length: 15 + Math.random() * 20,
                    opacity: 0.4 + Math.random() * 0.4
                });
            }
            
            raindrops.forEach((drop, index) => {
                // Gota principal
                ctx.strokeStyle = `rgba(174, 194, 224, ${drop.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 3, drop.y + drop.length);
                ctx.stroke();
                
                // Efecto de estela
                ctx.strokeStyle = `rgba(174, 194, 224, ${drop.opacity * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(drop.x - 1, drop.y + drop.length * 0.3);
                ctx.lineTo(drop.x - 2, drop.y + drop.length * 0.7);
                ctx.stroke();
                
                drop.y += drop.speed;
                drop.x -= 3;
                
                // Efecto de salpicadura al tocar el suelo
                if (drop.y > canvas.height - 30 && drop.y < canvas.height) {
                    ctx.fillStyle = `rgba(174, 194, 224, ${drop.opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(drop.x, canvas.height - 20, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (drop.y > canvas.height) {
                    raindrops.splice(index, 1);
                }
            });
            
            // Neblina de lluvia
            ctx.fillStyle = 'rgba(150, 160, 180, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.7);
            
            // RelÃ¡mpagos ocasionales
            if (Math.random() < 0.002) {
                lightningFlashes.push({
                    x: Math.random() * canvas.width,
                    branches: [],
                    opacity: 1,
                    life: 0
                });
                
                // Generar ramas del relÃ¡mpago
                const flash = lightningFlashes[lightningFlashes.length - 1];
                let currentX = flash.x;
                let currentY = 0;
                
                for (let i = 0; i < 8; i++) {
                    const nextX = currentX + (Math.random() - 0.5) * 50;
                    const nextY = currentY + 50 + Math.random() * 40;
                    flash.branches.push({x1: currentX, y1: currentY, x2: nextX, y2: nextY});
                    
                    // Ramas secundarias
                    if (Math.random() < 0.4) {
                        const branchX = nextX + (Math.random() - 0.5) * 80;
                        const branchY = nextY + 30 + Math.random() * 30;
                        flash.branches.push({x1: nextX, y1: nextY, x2: branchX, y2: branchY});
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                }
            }
            
            // Dibujar relÃ¡mpagos
            lightningFlashes.forEach((flash, index) => {
                flash.life++;
                flash.opacity = Math.max(0, 1 - flash.life * 0.1);
                
                if (flash.life < 10) {
                    ctx.strokeStyle = `rgba(200, 220, 255, ${flash.opacity})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
                    
                    flash.branches.forEach(branch => {
                        ctx.beginPath();
                        ctx.moveTo(branch.x1, branch.y1);
                        ctx.lineTo(branch.x2, branch.y2);
                        ctx.stroke();
                    });
                    
                    ctx.shadowBlur = 0;
                    
                    // Flash de luz en el cielo
                    ctx.fillStyle = `rgba(255, 255, 255, ${flash.opacity * 0.15})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height * 0.5);
                }
                
                if (flash.life > 10) {
                    lightningFlashes.splice(index, 1);
                }
            });
        }
        
        // Dibujar insectos (mariposas y abejas)
        function drawInsects(time) {
            const isDay = currentHour >= 8 && currentHour < 18;
            if (!isDay || currentWeather === 'rain') {
                insects = [];
                return;
            }
            
            // Crear insectos
            if (insects.length < 8 && Math.random() < 0.02) {
                const type = Math.random() < 0.6 ? 'butterfly' : 'bee';
                insects.push({
                    type: type,
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.3 + Math.random() * canvas.height * 0.4,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    wingPhase: Math.random() * Math.PI * 2,
                    size: type === 'butterfly' ? 8 : 5,
                    color: type === 'butterfly' 
                        ? `hsl(${Math.random() * 60 + 20}, 70%, 50%)` 
                        : '#FFD700'
                });
            }
            
            insects.forEach((insect, index) => {
                insect.wingPhase += 0.3;
                const wingScale = Math.abs(Math.sin(insect.wingPhase));
                
                if (insect.type === 'butterfly') {
                    // Mariposa
                    ctx.save();
                    ctx.translate(insect.x, insect.y);
                    
                    // Cuerpo
                    ctx.fillStyle = '#2C1810';
                    ctx.fillRect(-1, -insect.size * 0.3, 2, insect.size * 0.6);
                    
                    // Alas
                    ctx.fillStyle = insect.color;
                    ctx.globalAlpha = 0.7;
                    
                    // Ala izquierda
                    ctx.beginPath();
                    ctx.ellipse(-insect.size * 0.3, 0, insect.size * wingScale, insect.size * 0.8, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ala derecha
                    ctx.beginPath();
                    ctx.ellipse(insect.size * 0.3, 0, insect.size * wingScale, insect.size * 0.8, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    
                } else {
                    // Abeja
                    ctx.save();
                    ctx.translate(insect.x, insect.y);
                    
                    // Cuerpo
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, insect.size * 0.6, insect.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rayas
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    for (let i = -1; i <= 1; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * 2, -insect.size * 0.4);
                        ctx.lineTo(i * 2, insect.size * 0.4);
                        ctx.stroke();
                    }
                    
                    // Alas
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(-insect.size * 0.3, -insect.size * 0.2, insect.size * 0.4 * wingScale, insect.size * 0.3, -0.5, 0, Math.PI * 2);
                    ctx.ellipse(insect.size * 0.3, -insect.size * 0.2, insect.size * 0.4 * wingScale, insect.size * 0.3, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // Movimiento errÃ¡tico
                insect.x += insect.vx;
                insect.y += insect.vy + Math.sin(time * 0.005 + index) * 0.5;
                
                if (Math.random() < 0.02) {
                    insect.vx = (Math.random() - 0.5) * 2;
                    insect.vy = (Math.random() - 0.5) * 2;
                }
                
                if (insect.x < -20 || insect.x > canvas.width + 20 || 
                    insect.y < canvas.height * 0.2 || insect.y > canvas.height) {
                    insects.splice(index, 1);
                }
            });
        }
        
        // Dibujar cÃ©sped
        function drawGrass(time) {
            const colors = getSkyColors(currentHour);
            const baseAmbient = colors.ambient;
            const grassBase = baseAmbient > 0.7 ? [80, 160, 80] : [40, 100, 60];
            
            // Calcular posiciÃ³n del sol para iluminaciÃ³n dinÃ¡mica
            const dayProgress = Math.max(0, Math.min(1, (currentHour - 6) / 14));
            const sunX = canvas.width * 0.1 + (canvas.width * 0.8) * dayProgress;
            const isMorning = currentHour >= 5 && currentHour < 9;
            
            grassBlades.forEach((blade, index) => {
                blade.sway += blade.swaySpeed * (currentWeather === 'windy' ? 2 : 1);
                const swayOffset = Math.sin(blade.sway) * blade.swayAmount * (currentWeather === 'windy' ? 1.5 : 1);
                
                // Aplicar Ã¡ngulo de doblado para briznas caÃ­das
                const finalSwayOffset = blade.bent ? swayOffset * (1 + blade.bentAngle) : swayOffset;
                
                // VariaciÃ³n de color para realismo
                const adjustedBase = grassBase.map((c, i) => {
                    if (i === 1) return Math.max(0, Math.min(255, c + blade.colorVariation));
                    return c;
                });
                
                // IluminaciÃ³n dinÃ¡mica segÃºn posiciÃ³n del sol
                const distanceFromSun = Math.abs(blade.x - sunX) / canvas.width;
                const lightingFactor = 1 + (1 - distanceFromSun) * 0.3 * baseAmbient;
                
                const litBase = adjustedBase.map(c => Math.floor(c * lightingFactor));
                
                // Gradiente con textura
                const gradient = ctx.createLinearGradient(
                    blade.x, canvas.height,
                    blade.x + finalSwayOffset, canvas.height - blade.height
                );
                
                const darkGrass = litBase.map(c => Math.floor(c * 0.6));
                const midDarkGrass = litBase.map(c => Math.floor(c * 0.8));
                const lightGrass = litBase.map(c => Math.floor(c * 1.15));
                const tipGrass = litBase.map((c, i) => {
                    if (i === 1) return Math.floor(c * 1.3);
                    return Math.floor(c * 1.1);
                });
                
                gradient.addColorStop(0, `rgb(${darkGrass.join(',')})`);
                gradient.addColorStop(0.3, `rgb(${midDarkGrass.join(',')})`);
                gradient.addColorStop(0.7, `rgb(${litBase.join(',')})`);
                gradient.addColorStop(0.9, `rgb(${lightGrass.join(',')})`);
                gradient.addColorStop(1, `rgb(${tipGrass.join(',')})`);
                
                ctx.fillStyle = gradient;
                
                // Dibujar tallo con curva mÃ¡s natural
                ctx.beginPath();
                ctx.moveTo(blade.x, canvas.height);
                
                const controlY1 = canvas.height - blade.height * 0.3;
                const controlY2 = canvas.height - blade.height * 0.7;
                
                ctx.bezierCurveTo(
                    blade.x + finalSwayOffset * 0.2, controlY1,
                    blade.x + finalSwayOffset * 0.6, controlY2,
                    blade.x + finalSwayOffset, canvas.height - blade.height
                );
                
                ctx.lineTo(blade.x + blade.width + finalSwayOffset, canvas.height - blade.height);
                
                ctx.bezierCurveTo(
                    blade.x + blade.width + finalSwayOffset * 0.6, controlY2,
                    blade.x + blade.width + finalSwayOffset * 0.2, controlY1,
                    blade.x + blade.width, canvas.height
                );
                
                ctx.closePath();
                ctx.fill();
                
                // LÃ­nea central (nervadura) para detalle
                if (blade.width > 2.5) {
                    ctx.strokeStyle = `rgba(${darkGrass.join(',')}, 0.4)`;
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(blade.x + blade.width / 2, canvas.height);
                    
                    ctx.bezierCurveTo(
                        blade.x + blade.width / 2 + finalSwayOffset * 0.2, controlY1,
                        blade.x + blade.width / 2 + finalSwayOffset * 0.6, controlY2,
                        blade.x + blade.width / 2 + finalSwayOffset, canvas.height - blade.height
                    );
                    ctx.stroke();
                }
                
                // Gotas de rocÃ­o en la maÃ±ana
                if (isMorning && currentWeather !== 'rain' && Math.random() < 0.05) {
                    const dewY = canvas.height - blade.height * (0.3 + Math.random() * 0.4);
                    const dewX = blade.x + blade.width / 2 + finalSwayOffset * (0.3 + Math.random() * 0.4);
                    
                    // Gota de rocÃ­o con brillo
                    const dewGradient = ctx.createRadialGradient(
                        dewX, dewY, 0,
                        dewX, dewY, 3
                    );
                    dewGradient.addColorStop(0, 'rgba(200, 220, 255, 0.9)');
                    dewGradient.addColorStop(0.5, 'rgba(150, 180, 220, 0.6)');
                    dewGradient.addColorStop(1, 'rgba(150, 180, 220, 0.2)');
                    
                    ctx.fillStyle = dewGradient;
                    ctx.beginPath();
                    ctx.arc(dewX, dewY, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reflejo de luz en la gota
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(dewX - 0.8, dewY - 0.8, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Agregar capa de hierba en el suelo con textura
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
            const groundBase = grassBase.map(c => Math.floor(c * 0.5));
            const groundTop = grassBase.map(c => Math.floor(c * 0.7));
            
            groundGradient.addColorStop(0, `rgba(${groundTop.join(',')}, 0.6)`);
            groundGradient.addColorStop(1, `rgba(${groundBase.join(',')}, 0.9)`);
            
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
            
            // Textura de tierra
            ctx.fillStyle = `rgba(${groundBase.map(c => Math.floor(c * 0.8)).join(',')}, 0.3)`;
            for (let i = 0; i < canvas.width; i += 10) {
                if (Math.random() < 0.3) {
                    ctx.fillRect(i, canvas.height - 25 + Math.random() * 20, 2 + Math.random() * 3, 1);
                }
            }
        }
        
        // Dibujar luciÃ©rnagas (noche)
        function drawFireflies(time) {
            const isNight = currentHour >= 20 || currentHour < 6;
            if (!isNight) {
                fireflies = [];
                return;
            }
            
            // Crear luciÃ©rnagas
            if (fireflies.length < 15 && Math.random() < 0.05) {
                fireflies.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.4 + Math.random() * canvas.height * 0.3,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    brightness: 0,
                    phase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.05 + Math.random() * 0.05
                });
            }
            
            fireflies.forEach((firefly, index) => {
                firefly.phase += firefly.pulseSpeed;
                firefly.brightness = Math.sin(firefly.phase) * 0.5 + 0.5;
                
                const glow = ctx.createRadialGradient(firefly.x, firefly.y, 0, firefly.x, firefly.y, 15);
                glow.addColorStop(0, `rgba(255, 255, 150, ${firefly.brightness * 0.8})`);
                glow.addColorStop(0.3, `rgba(255, 255, 150, ${firefly.brightness * 0.4})`);
                glow.addColorStop(1, 'rgba(255, 255, 150, 0)');
                
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(firefly.x, firefly.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                firefly.x += firefly.vx;
                firefly.y += firefly.vy;
                
                if (Math.random() < 0.02) {
                    firefly.vx = (Math.random() - 0.5) * 2;
                    firefly.vy = (Math.random() - 0.5) * 2;
                }
                
                if (firefly.x < 0 || firefly.x > canvas.width || 
                    firefly.y < canvas.height * 0.3 || firefly.y > canvas.height * 0.9) {
                    fireflies.splice(index, 1);
                }
            });
        }
        
        // Dibujar semillas de diente de leÃ³n (dÃ­a)
        function drawDandelionSeeds(time) {
            const isDay = currentHour >= 7 && currentHour < 19;
            if (!isDay && currentWeather !== 'windy') {
                dandelionSeeds = [];
                return;
            }
            
            // Crear semillas
            if (dandelionSeeds.length < 20 && Math.random() < 0.03) {
                dandelionSeeds.push({
                    x: -20,
                    y: canvas.height * 0.4 + Math.random() * canvas.height * 0.3,
                    vx: 1 + Math.random() * 2,
                    vy: -1 + Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    size: 8 + Math.random() * 6,
                    wobble: Math.random() * Math.PI * 2
                });
            }
            
            dandelionSeeds.forEach((seed, index) => {
                ctx.save();
                ctx.translate(seed.x, seed.y);
                ctx.rotate(seed.rotation);
                
                // Tallo central con gradiente
                const stemGradient = ctx.createLinearGradient(0, 0, 0, seed.size * 1.5);
                stemGradient.addColorStop(0, 'rgba(160, 130, 90, 0.8)');
                stemGradient.addColorStop(0.5, 'rgba(139, 115, 85, 0.7)');
                stemGradient.addColorStop(1, 'rgba(120, 100, 70, 0.5)');
                
                ctx.strokeStyle = stemGradient;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, seed.size * 1.5);
                ctx.stroke();
                
                // Pelusa principal con mÃ¡s detalle
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const distance = seed.size * 0.4;
                    const fluffX = Math.cos(angle) * distance;
                    const fluffY = Math.sin(angle) * distance;
                    
                    // Tallo de cada pelusa
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, seed.size * 0.3);
                    ctx.lineTo(fluffX, fluffY);
                    ctx.stroke();
                    
                    // Cabeza de pelusa con gradiente radial
                    const fluffGradient = ctx.createRadialGradient(
                        fluffX, fluffY, 0,
                        fluffX, fluffY, seed.size * 0.25
                    );
                    fluffGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    fluffGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.6)');
                    fluffGradient.addColorStop(1, 'rgba(245, 245, 245, 0.2)');
                    
                    ctx.fillStyle = fluffGradient;
                    ctx.beginPath();
                    ctx.arc(fluffX, fluffY, seed.size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Detalles finos de pelusa
                    for (let j = 0; j < 3; j++) {
                        const microAngle = angle + (j - 1) * 0.2;
                        const microDist = distance * 1.1;
                        const microX = Math.cos(microAngle) * microDist;
                        const microY = Math.sin(microAngle) * microDist;
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(fluffX, fluffY);
                        ctx.lineTo(microX, microY);
                        ctx.stroke();
                    }
                }
                
                // Centro de la semilla
                ctx.fillStyle = 'rgba(200, 180, 140, 0.8)';
                ctx.beginPath();
                ctx.arc(0, seed.size * 0.3, seed.size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                seed.wobble += 0.02;
                seed.x += seed.vx * (currentWeather === 'windy' ? 2 : 1);
                seed.y += Math.sin(seed.wobble) * 0.8 + seed.vy * 0.3;
                seed.rotation += seed.rotationSpeed;
                
                if (seed.x > canvas.width + 50 || seed.y > canvas.height || seed.y < -50) {
                    dandelionSeeds.splice(index, 1);
                }
            });
        }
        
        // Loop de animaciÃ³n
        function animate(time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawSky();
            drawStars();
            drawSunRays();
            drawCelestialBody();
            drawClouds();
            drawAtmosphericParticles(time);
            drawRain();
            drawInsects(time);
            drawDandelionSeeds(time);
            drawGrass(time);
            drawFireflies(time);
            
            requestAnimationFrame(animate);
        }
        
        // Controles
        document.getElementById('hourSlider').addEventListener('input', (e) => {
            currentHour = parseInt(e.target.value);
            document.getElementById('hourDisplay').textContent = `${currentHour}:00`;
            autoMode = false;
            document.getElementById('autoMode').checked = false;
        });
        
        document.getElementById('weatherSelect').addEventListener('change', (e) => {
            currentWeather = e.target.value;
        });
        
        document.getElementById('autoMode').addEventListener('change', (e) => {
            autoMode = e.target.checked;
            if (autoMode) {
                currentHour = new Date().getHours();
                document.getElementById('hourSlider').value = currentHour;
                document.getElementById('hourDisplay').textContent = `${currentHour}:00`;
            }
        });
        
        // Actualizar hora automÃ¡ticamente
        setInterval(() => {
            if (autoMode) {
                currentHour = new Date().getHours();
                document.getElementById('hourSlider').value = currentHour;
                document.getElementById('hourDisplay').textContent = `${currentHour}:00`;
            }
        }, 60000);
        
        // Iniciar animaciÃ³n
        animate(0);
    </script>
</body>
</html>
